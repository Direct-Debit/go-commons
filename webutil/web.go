package webutil

import (
	"bytes"
	"encoding/json"
	"errors"
	"github.com/Direct-Debit/go-commons/errlib"
	"io"
	"io/ioutil"
	"net/http"
	"strings"
)

// Write err.Error() in a JSON object to w and return true if err != nil.
// Return from your handler function if this method returns true.
// The JSON object will be the same as one generated by ErrorResponder
func ClientError(w http.ResponseWriter, err error, info map[string]interface{}, code int) bool {
	if err == nil {
		return false
	}
	ErrorResponder(err.Error(), info, code).ServeHTTP(w, nil)
	return true
}

// Return an http.Handler that writes {"error": msg} with the given error code
// info["error"] will be overridden with value of msg
func ErrorResponder(msg string, info map[string]interface{}, code int) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Add("Content-Type", "application/json")
		w.WriteHeader(code)

		if info == nil {
			info = make(map[string]interface{}, 1)
		}
		info["error"] = msg

		writer := json.NewEncoder(w)
		errlib.PanicError(writer.Encode(info), "Couldn't encode JSON error")
	})
}

func RequestBody(r *http.Request, consume bool) string {
	buff := new(bytes.Buffer)
	_, err := io.Copy(buff, r.Body)
	errlib.PanicError(err, "Couldn't copy request body")
	if !consume {
		r.Body = ioutil.NopCloser(buff)
	}
	return buff.String()
}

func ResponseBody(r *http.Response, consume bool) string {
	buff := new(bytes.Buffer)
	_, err := io.Copy(buff, r.Body)
	errlib.PanicError(err, "Couldn't copy response body")
	if !consume {
		r.Body = ioutil.NopCloser(buff)
	}
	return buff.String()
}

func ParseRequestJSON(r *http.Request, target interface{}) error {
	return json.NewDecoder(r.Body).Decode(target)
}

func ParseResponseJSON(r *http.Response, target interface{}) error {
	return json.NewDecoder(r.Body).Decode(target)
}

// Read the JSON in the Response Body into a map
func ParseResponseMap(r *http.Response) (map[string]interface{}, error) {
	var m map[string]interface{}
	err := ParseResponseJSON(r, &m)
	if err != nil {
		return nil, err
	}
	return m, nil
}

// Get the specified field from the response.
// Raise an error if the field is not present or the body isn't valid JSON
func ResponseField(r *http.Response, field string) (interface{}, error) {
	m, err := ParseResponseMap(r)
	if err != nil {
		return nil, err
	}
	v, ok := m[field]
	if !ok {
		return nil, errors.New(field + " is not in the response body")
	}
	return v, nil
}

func WriteJSON(w http.ResponseWriter, v interface{}) error {
	w.Header().Set("Content-Type", "application/json")
	return json.NewEncoder(w).Encode(v)
}

// Get the Content-Type from the header.
// Return "" if there is no Content-Type header.
func GetContentType(h http.Header) string {
	// Based on https://github.com/gorilla/handlers/blob/v1.5.1/handlers.go#L85
	ct := h.Get("Content-Type")
	if i := strings.IndexRune(ct, ';'); i != -1 {
		return ct[0:i]
	}
	return ct
}
